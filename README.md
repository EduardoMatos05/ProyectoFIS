# Video

[Link](https://youtu.be/SaOdiAgUM2E)


## 2.1
**Knowledge of Tools:**
It is crucial to familiarize oneself with tools used in the realm of software engineering. This encompasses project management tools, version control, and specific tools for documentation and requirement tracking. Effectively utilizing these tools contributes to efficiency and quality in requirement management.

**Experience with Enterprise Modeling:**
Enterprise modeling involves graphically representing the structure and processes of an organization. Understanding and applying modeling techniques are vital to comprehend the rationale behind software development. This facilitates the identification and understanding of requirements, as well as effective communication among team members and stakeholders.

**Knowledge of Security Standards:**
Security is a critical concern in software development. Acquiring knowledge about security standards, such as ISO/IEC 27001 or NIST, is fundamental. This helps integrate security measures from the early stages of the requirement engineering cycle, ensuring the final product is robust against potential threats.

**Example within Our Project:**
By refining requirements and documenting them in a table, we ensure a clear understanding for interface designers, avoiding possible confusion and guaranteeing efficient communication within the team. This experience emphasized the critical importance of precise modeling in the requirement engineering cycle, fundamental to the success of the project.

## 2.2
The use cases and user  stories share certain  characteristics as they  help  us describe and specify  system  requirements. However, despite  both  being  oriented  towards  the  user  perspective, we can find  significant  differences. Primarily, use cases address  different  interactions  between  the  system and the  user and can become more complex. On  the  other  hand, user  stories  focus  on a single  functionality/feature and are designed  to be easily  understood. Another  important  difference  is  that use cases concentrate  on  the  actions and behaviors  of  the  system  based  on  what a user  might do, rather  than a real user  perspective. In contrast, a user  story  typically  emphasizes  the  expected  outcomes  from  the  end  user's  perspective.

With  these  differences  addressed, we can say  that use cases are more suitable  when  working  on  large  projects  or  when  detailed  information  about  various  interactions  is  needed. On  the  other  hand, user  stories are ideal for agile and small  projects  where  continuous  delivery  is  prioritized, flexibility  is  required  to  adapt  to  changes, or  there  is more direct  collaboration  with  users. User  stories are effective as they are expressed in a more understandable  language.

In our  team's  experience, we  opt  for use cases. Since  our  project  is  not  something  that  will be publicly  launched, there  is no need  to  have  contact  with real users. Instead, it  is more fitting  for  our  project  to define possible  user  interactions  with  the  product.

## 2.3
**Product: User Interface**  
**Method: User-Centered Design (UCD) (Diseño centrado en el usuario (DCU))**  
The  method  focuses  on  user  preferences and consists  of  five  stages: research, concept, design, evaluation, and launch. These  phases  aim  to  gather diverse opinions  on  the software and maintain  constant tracking for a more secure and user-aligned  development. Initially, the  type  of  individuals  who  will use the software is  identified, followed  by  the  collection  of  relevant  information  about  their  needs and preferences  through interviews, surveys, and usability  testing.

At the  project's  outset, before  addressing  the  user  interface, we  consulted  with  individuals  who  matched  the  characteristics set for  the future software users. This  helped  us  truly  understand  what  the  interface  needed and what  it  didn't, saving  us time and potential  issues. Additionally, once the  prototypes  were  created, we  planned  to  conduct  usability  tests  with real users. This  would  enable  us  to  gather  information  on  user  interaction  with  the  interface, with  the  aim  of  optimizing  the  user  experience and ensuring  easy  comprehension.

If  we  hadn't  established  from  the  beginning  who  our  primary  users  would be or  consulted  people  about  the  interface, we  would  have  faced  various  problems in choosing  the software design. This  would  have  required more time, and we  wouldn't  have  had  constant  monitoring  of  areas  for  improvement. This  method  provides  us  with  the  opportunity  to  adjust  the  user  interface  according  to  needs, ensuring  it  is intuitive and meets  the  expected  expectations.

## 2.4
The method that we investigated, which allowed us to do the testing during development, was prototyping, which consists of making a preliminary version of the software  interfaces and the refinement of requirements, which is the most common use, all of this arises during a rapid cycle where first the objective of the prototype is communicated, then it is developed and finally tested and from that test feedback is obtained with which the cycle is repeated but allowing improvement as it is repeated until the desired result is obtained.

It has advantages such as reducing costs by eliminating errors when debugging prototypes, avoiding the expenditure of costs and resources when having to correct them, it can begin to be used from the early stages of design to carry out and is widely used in the coding part. The disadvantages it can have are that the cost can increase if overused, it can leave out non-functional requirements, and it makes it difficult to maintain the software in the long term if it is poorly implemented.

A situation that occurred during development was that during the creation of our requirements in their first versions, which later had to be adjusted with the help of use cases and user stories so that later they gave way to the first ones. UI versions of our software based on more solid requirements.

## 2.5
Developing secure software applications requires a solid foundation in various key areas. According to the material provided by Stanford University in its Computer Security course ([Stanford University - Computer Security](https://crypto.stanford.edu/cs155old/cs155-spring07/Handouts/intro.pdf)), knowledge in cryptography and information security is fundamental. Understanding the principles of encryption, authentication, and access control forms the basis for protecting the integrity and confidentiality of data in applications. 

Likewise, according to the OWASP report on the top ten security vulnerabilities in web applications ([OWASP Top Ten](https://owasp.org/www-project-top-ten/)), a software engineer must be familiar with these vulnerabilities to mitigate potential risks. This knowledge allows for identifying and addressing weaknesses in software development, ensuring greater resilience against possible attacks. 

Additionally, the CEH (Certified Ethical Hacker) certification ([CEH Certification](https://www.eccouncil.org/programs/certified-ethical-hacker-ceh/)) offers comprehensive training in penetration testing, enabling professionals to assess the security of systems and applications, identifying potential vulnerabilities and thereby strengthening software security. 

Lastly, maintaining constant updates is key. Following specialized blogs like Krebs on Security ([Krebs on Security](https://krebsonsecurity.com/)) or Troy Hunt ([Troy Hunt](https://www.troyhunt.com/)), which provide updated information on emerging threats and vulnerabilities, is essential to stay abreast of current challenges in computer security. 

In summary, comprehensive training covering cryptography, knowledge of vulnerabilities, good coding practices, penetration testing, and continuous updating constitute the foundation for the development of secure software applications.

## 3.1
According to the "UAY!" project, which is based on the use of an Outlook extension that allows users to display desired notifications on their mobile devices, the different problems and possible solutions that may arise from the project are: 
- **Individuals and interactions over processes and tools:** 
  - **Conflict:** Misunderstandings and disagreements within the team and with the client to the extent of not meeting the desired outcome. 
  - **Solution:** Weekly video conferences between the team and the project evaluator. The project clearly specifies the tool offered to select the email destination, facilitating the prompt arrival of the email and enabling the user to interact effectively with the extension. 
 
- **Working software over comprehensive documentation:** 
  - **Conflict:** Issues with large amounts of unnecessary information, becoming tiresome for the user's view. 
  - **Solution:** UAY! maintains a tool concept that delivers software with various wireframes containing essential information and uses buttons to guide to different areas. 
 
- **Collaboration with the client over contract negotiation:** 
  - **Conflict:** Probability of changes with the agile value of continuous collaboration if strict contract tracking with the client is maintained. 
  - **Solution:** Maintaining an open relationship with the client, for example, by involving them in scheduled video conferences to provide feedback on completed and planned functionalities of the extension. Prioritizing the client and adapting to their needs specified in the initial contract. 
 
- **Responding to change over following a plan:** 
  - **Conflict:** Based on experiences within the team, the project undergoes various changes from its inception to the current state, requiring the working team to be prepared for changes within the plan. 
  - **Solution:** The working team is divided into different areas, with a designated project guide similar to a scrum master/product owner. Additionally, there is a QA tester responsible for ensuring no flaws or errors exist in the project, and the development team, responsible for creating UI and UX tools for the client. Essentially, it is a model similar to scrum that divides work for development and the numerous changes that may occur during the project timeline to achieve a positive agile response.

## 3.2
From the agile methodologies (Scrum, XP, Kanban, Design sprint, etc.), select 2 of those and identify at least 3 principles of agility of software that are in said methodologies. 
Also explain how you can integrate those agility principles in your team’s project, supposing you follow an agile methodology. 

### In Scrum: 
- At regular intervals, the team reflects on how to become more effective, then tunes and adjusts its behavior accordingly.
- Continuous attention to technical excellence and good design enhances agility.
- The best architecture, requirements, and designs emerge from self-organizing teams.

### In Extreme Programming (XP): 
- The best architectures, requirements, and designs emerge from self-organizing teams.
- The most efficient and effective method of conveying information to and within a development team is face-to-face conversation.
- Simplicity--the art of maximizing the amount of work not done--is essential.

#### How can we apply it to our project? 
We could apply these principles of agility to our project, since if each member self-organizes for the work and there is no need to pressure them to carry out their activities, the project will advance faster. Likewise, if we have face-to-face conversations about the project, we maintain a much clearer understanding of what is happening in the project, as well as reaching an agreement with the team members. On the other hand, if we focus on carrying out the necessary activities for the project without carrying out more than necessary, the workload would be more fluid, and finally, if at the end of each delivery the team meets to talk and reflect on the results obtained and how the process was, the necessary corrections could be made in the process and the organization so that in this way the team can improve internally through direct feedback from the team members.


## Bibliography

Kent, B. (2001). Principles behind the Agile Manifesto. Manifesto for Agile Software Development. [Link](https://agilemanifesto.org/principles.html)

Well, D. (2009). Agile Software Development: A gentle introduction. Agile Process. [Link](http://www.agile-process.org)

Schwaber, K. y Sutherland, J. (2020). The 2020 Scrum GuideTM. Scrum Guides. [Link](https://scrumguides.org/scrum-guide.html)

"What does a Requirements Engineer do?" FreelancerMap. [Link](https://www.freelancermap.com/blog/es/que-hace-ingeniero-requisitos/#:~:text=Habilidades%20del%20Ingeniero%20de%20Requisitos&text=Este%20perfil%20laboral%20exige%20coordinar,de%20liderazgo%2C%20flexibilidad%20y%20resiliencia.)

"Agile" - UOC Open Access. [Link](https://openaccess.uoc.edu/bitstream/10609/144552/1/Agile.pdf)

"Manifesto Ágil: Aceptamos que los requisitos cambien..." José Huerta. [Link](https://josehuerta.es/gestion/agile/manifiesto/aceptamos-que-los-requisitos-cambien-incluso-en-etapas-tardias-del-desarrollo-los-procesos-agiles-aprovechan-el-cambio-para-proporcionar-ventaja-competitiva-al-cliente)

"Iberdrola - Diseño Centrado en el Usuario." Iberdrola. [Link](https://www.iberdrola.com/innovacion/que-es-diseno-centrado-en-el-usuario#:~:text=PROCESO%20DE%20DISE%C3%91O%20CENTRADO%20EN%20EL%20USUARIO%20(DCU)&text=Se%20analizan%20las%20caracter%C3%ADsticas%20de,la%20tarea%20y%20el%20entorno.)

Denise, S. y Carmen, G. (2021). "Prototipo: qué es y para qué sirve." Freed Tools. [Link](https://freed.tools/blogs/ux-cx/prototipo)
